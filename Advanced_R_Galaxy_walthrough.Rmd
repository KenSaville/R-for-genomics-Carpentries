---
title: "R for genomics_Galaxy_version"
output: html_document
date: "2023-09-06"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This document follows the Advanced R in Galaxy tutorial from usegalaxy.org, with a few additions / modifications added by me.

First - read in the file of annotated genes

```{r}
## read in a CSV file and save it as 'annotatedDEgenes'
annotatedDEgenes <- read.csv("https://zenodo.org/record/3477564/files/annotatedDEgenes.tabular", sep = "\t")

## note that because this is a tab delimted file, sep = \t needs to be included in the read.csv command.

## reading it in with the default csv parameter results in a file with only one variable.  Reading it in with sep = /t creates 13 variables (columns)

```


View the file with the View command.  After Viewing this, comment out the View command

```{r}
#View(annotatedDEgenes)
```

List the names of the columns

```{r}
colnames(annotatedDEgenes)
```
This data is RNA seq data from a previous Galaxy tutorial.  The essential data consists of "counts" of sequencing reads that map to specific genes in the Drosophila genome.

Below is a brief description of each column from that tutorial

GeneID:  Gene identifiers
Base.mean:   Mean normalized seq read counts over all samples
log2.FC:  Log2 fold change
StdErr:   Standard error estimate for the log2 fold change estimate
Wald.Stats:   Wald statistic
P.value:   p-value for the Wald statistic
P.adj:   p-value adjusted for multiple testing with the Benjamini-Hochberg              procedure for the Wald statistic
Chromosome:  Which chromosome the gene is on
Start:   Starting DNA coordinate of the gene
End:  Ending DNA coordinate of the gene
Strand:  strand (+ or -) the gene is on in the reference genome.
Feature:  What type of gene it is (protein coding, non-coding, etc)
Gene name:  kinda self explanatory, the name of the gene.

For this tutorial, the details of the various statistical measures aren't important, as we are simply using this data as an example data table for performing some R manipulations.  For more details on the RNA sequence analysis, see the [Reference-based RNA-Seq data analysis](https://training.galaxyproject.org/training-material/topics/transcriptomics/tutorials/ref-based/tutorial.html#annotation-of-the-deseq2-results)

### Now let's play around with this dataframe

Tabular data are stored in R using data frame. A data frame could also be thought of as a collection of vectors, all of which have the same length.

```{r}

## get summary statistics on a data frame.  The summary function calculates and dispays basic descriptive statistics for each column of data (if the data is numerical and amenable to these calculations)

summary(annotatedDEgenes)
```

Another way to inspect the datframe is to use the structure function:  str().  This tells us the name of each column, the type of data in each column and the first few cvlaues in each column.  To learn more about the structure column type ?str

```{r}
#learn more about the str function

?str
# Use the str() function on our dataframe.  Type str() and start typing the name of the data frame ann then hit the tab key to complete the name.  Using the tab key helps avoid spelling mistakes and ensures that the dataframe is available in the place we are looking for it.

str(annotatedDEgenes)

#It may help to widen this window so the info for each column is displayed on one line.
```
Ok, thats a lot to unpack! Some things to notice:

The object type data.frame is displayed in the first row along with its dimensions, in this case 130 observations (rows) and 13 variables (columns)

Each variable (column) has a name (e.g. GeneID). This is followed by the object mode (e.g. factor, int, num, etc.). Notice that before each variable name there is a $ - this will be important later.
So from both summary and str, we know that our data frame had 13 variables that summarize the data.

Base.mean, log2.FC. and P.value variables (and several others) are numerical data

From the summary function, we get summary statistics on the min and max values for these columns, as well as mean, median, and interquartile ranges

Many of the other variables (e.g. Strand) are treated as categorical data

This type has special treatment in R - more on this in a bit. The most frequent 6 different categories and the number of times they appear (e.g. the Strand called - appeared 58 times) are displayed. Another example is the protein_coding value for Feature which appeared in 126 observations.

## Factors

Factors, the final major data structure we will introduce, can be thought of as vectors which are specialized for categorical data. Given Râ€™s specialization for statistics, this make sense since categorial and continuous variables usually have different treatments. Sometimes you may want to have data treated as a factor, but in other cases, this may be undesirable.

A factor let's you organize data by categories.  For example, if you had data on organisms based on the old kingdom rules you might have plant, animal, fungi ... as factors.  Then you could act perform a function only on animals for example.

Since some of the data in our data frame are factors, lets see how factors work.

When we import the data using the command above, the character data did not come in as factor data as it is supposed to according to the galaxy walkthrough.

Here, we can convert the chr data to factor data, so that our data frame is consistent with the tutorial.  There are various ways to do this.  Here we will try a function from the dplyr package called mutateif.  This will change (mutate) data in a dataframe based on some condition.  We will cover some other basic functions of dplyr a bit later.

first we need to install and load the dplyr pakcge.  dplyr is part of what is called the tidyverse, so we'll install the tiduverse which has lots of other useful packages.

```{r}
install.packages("tidyverse")
library(tidyverse)

```
now wecan run mutate_if, because it is part of the now loaded dplyr package

```{r}
#we will store the modified data frame with the same name 

annotatedDEgenes <- annotatedDEgenes %>% mutate_if(is.character, as.factor)

#the above code can be read as follows:  
#The expression on the right says: input the annotatedDEgenes datframe into the mutateif function.  Within this functio look for everything that is a character (is.character) and change it to factor (as.factor).  the annotatedDEgenes on the left is saying to take the results of the function on the right and store it back in the annotatedDEgenes variable.  Let's see if it works.  Run this code block.
```

Now let's look at the data frame and see if we have factor data

```{r}
#check structure of modified dataframe.
str(annotatedDEgenes)
```


```{r}
## extract the "feature" column to a new object
feature <- annotatedDEgenes$Feature

# here's where that dollar sign symbol comes in.  Using the $ symbol we can designate specific columns.  annotatedDEgene$Feature refers to the Feature column of the annotatedDEgenes dataframe.


```

Let's look at the first few entries n the Feature column using the head() function.

```{r}
#we could use the head function directly on the features column within the dta frame like this:

head(annotatedDEgenes$Feature)

#But because we already extracted that column into a new object called feature, we can do this

head(feature)

# both give the same thing.  The fact that it list levels tells us that the data is being treated as a factor.

```
We can also check how many levels there are by using the levels function.  This function works on 

```{r}
#check how many levels in the feature column that we just extracted.
levels(feature)
```

And let's check the stucture of feature

```{r}
str(feature)

```
To get an idea of how factor data can be useful, let's make a basic plot of the feature data.  In base R there is a function called plot().  It is a quick way to generate a plot (or graph) of some data.  The function generally figures out the best type of plot based on the data.  While this is helpful for quick looks at the data, more advanced plotting techniques are available.  We'll cover those later.

Here let's just plot the feature data

```{r}
#generate a simple plot of feature data

plot(feature)

```

Simple enough.  The plot function counted up the number of genes in each of of the factor "levels" and made a bar graph.  If the data wasn't in factor form, plot would not generate this plot.  Let's demonstrate

```{r}
#convert feature data back to character.  Save it as feature_chr

feature_chr <- as.character(feature)

```

Let' see if that worked

```{r}
#check structure of feature chr vector
str(feature_chr)

#now try to plot it
plot(feature_chr)

```

Note that the plot didn't know what to do with this data.  We could certainly write some ode to count up the number of each type of gene, but the factor aspect of the data makes it much easier.

Now let's remove the factor_chr data to avoid confusion

```{r}
rm(feature_chr)
```

###Subset a data frame

Now we would like to know how to get specific values from data frames, and where necessary, change the mode of a column of values.

A data frame is two-dimensional (rows and columns). Therefore, to select a specific value we will use [] (bracket) notation.  The basic way to subset the data frame is to indicate the row as the first number and the column as the second number.  It looks like this, where df stands for the name of the data frame.

Here are some ways to write the subsetting notation.  In general,

Use of 2 values, separated by commas: data.frame[row, column]
Use of a colon between the numbers (start:stop, inclusive) for a continuous range of numbers (e.g. dataframe[1:4, 2])
Passing a vector using c() for a non continuous set of numbers
Index using the name of a column(s) by passing them as vectors using c()

SOme more general examples:

df[1,1]  selects the value in the first row, first column.

df [2, 4] selects the value in the second row, fourth column.

df[2, ] selects the second row, all columns (the commas is necessary.  df[2] would give an error)
df[-1, ] all rows except the last.  all columns
df[1:4, 1] rows 1 through 4, all columns

** you can also select columns by name.  the c() notation allows you to combine more than one column name.  Also - quotes are necessary for column names. **

df[1:10, c("Name of column 3", "Name of column 6")] rows 1 through 10, columns 3 and 6.

df[, c("column")] all rows 
head(df) the first 6 rows (6 is the default number of rows for the head function
head(df, 10).  The first 10 rows
tail(df) the last 6 rows (6 is the default number of rows for the tail function
tail(df, 10).  The last 10 rows

you can specify specific columns using dollar sign notation.  Generally this looks like 

df$columnName

A very useful feature is being to be able to select rows based on the value in that row for a specific column.

A general example would look like this,

```{r}
#df[df$ColumnName == "someSpecificTerm"].  The first df indicates the data frame name, the df$ColumnName part says "look in this column".  the == means "if it matches" "someSPecificTerm" is the thing to be matched.  This notation takes some getting used to and will be clearer wth real examples.

#I had to put this part in a code block because the $ symbol has a special interpretation in the R markdown part of the document.
```

Here are some examples uisng the annotatedDEgenes dataframe.  Run each line separately by placing your cursor at the end of the line and typing the ctrl-enter key combination

First I'll recall the column names so we know what to expect.  Also the rows are just specific geneIDs

```{r}
colnames(annotatedDEgenes)
```


```{r}
annotatedDEgenes[1, 1] #first row first column (the 1st geneID)
annotatedDEgenes[2, 4] #second row fourth column (a StdErr value for gene 2)
annotatedDEgenes[130, 13] #The last gene name
annotatedDEgenes[2, ] #all columns for row 2
annotatedDEgenes[-1, ] #All rows except the last all columns
annotatedDEgenes[1:4, 1] #genes 1-4, geneID
annotatedDEgenes[1:10, c("Feature", "Gene.name")] # rows 1-10, the Feature and Gene.name column*
annotatedDEgenes[, "Gene.name"] #the Gene name for all rows.
head(annotatedDEgenes)# first 6 rows
head(annotatedDEgenes, 10)# first 10 rows
tail(annotatedDEgenes) #last 6
tail(annotatedDEgenes, 10) #last 10
annotatedDEgenes$GeneID #the gene ID colun
annotatedDEgenes[annotatedDEgenes$Feature == "pseudogene", ] #all rows (genes) in the Feature column that match the term "pseudogene" (apparently there is only one)

#note"  the following doesn't work.  You need to designate the column as annotatedDEgenes$Feature

annotatedDEgenes["Feature" == "pseudogene", ]

#This does work
annotatedDEgenes[annotatedDEgenes[12] == "pseudogene", ]


annotatedDEgenes[annotatedDEgenes$Feature != "protein_coding", ] #all rows where the feature does not equal (!= means not equal or doesn't match) protein_coding.
```



