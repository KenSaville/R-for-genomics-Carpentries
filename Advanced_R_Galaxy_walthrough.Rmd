---
title: "R for genomics_Galaxy_version"
output: html_document
date: "2023-09-06"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This document follows the Advanced R in Galaxy tutorial from usegalaxy.org, with a few additions / modifications added by me.

First - read in the file of annotated genes

```{r}
## read in a CSV file and save it as 'annotatedDEgenes'
annotatedDEgenes <- read.csv("https://zenodo.org/record/3477564/files/annotatedDEgenes.tabular", sep = "\t")

## note that because this is a tab delimted file, sep = \t needs to be included in the read.csv command.

## reading it in with the default csv parameter results in a file with only one variable.  Reading it in with sep = /t creates 13 variables (columns)

```


View the file with the View command.  After Viewing this, comment out the View command

```{r}
#View(annotatedDEgenes)
```

List the names of the columns

```{r}
colnames(annotatedDEgenes)
```
This data is RNA seq data from a previous Galaxy tutorial.  The essential data consists of "counts" of sequencing reads that map to specific genes in the Drosophila genome.

Below is a brief description of each column from that tutorial

GeneID:  Gene identifiers
Base.mean:   Mean normalized seq read counts over all samples
log2.FC:  Log2 fold change
StdErr:   Standard error estimate for the log2 fold change estimate
Wald.Stats:   Wald statistic
P.value:   p-value for the Wald statistic
P.adj:   p-value adjusted for multiple testing with the Benjamini-Hochberg              procedure for the Wald statistic
Chromosome:  Which chromosome the gene is on
Start:   Starting DNA coordinate of the gene
End:  Ending DNA coordinate of the gene
Strand:  strand (+ or -) the gene is on in the reference genome.
Feature:  What type of gene it is (protein coding, non-coding, etc)
Gene name:  kinda self explanatory, the name of the gene.

For this tutorial, the details of the various statistical measures aren't important, as we are simply using this data as an example data table for performing some R manipulations.  For more details on the RNA sequence analysis, see the [Reference-based RNA-Seq data analysis](https://training.galaxyproject.org/training-material/topics/transcriptomics/tutorials/ref-based/tutorial.html#annotation-of-the-deseq2-results)

### Now let's play around with this dataframe

Tabular data are stored in R using data frame. A data frame could also be thought of as a collection of vectors, all of which have the same length.

```{r}

## get summary statistics on a data frame.  The summary function calculates and dispays basic descriptive statistics for each column of data (if the data is numerical and amenable to these calculations)

summary(annotatedDEgenes)
```

Another way to inspect the datframe is to use the structure function:  str().  This tells us the name of each column, the type of data in each column and the first few cvlaues in each column.  To learn more about the structure column type ?str

```{r}
#learn more about the str function

?str
# Use the str() function on our dataframe.  Type str() and start typing the name of the data frame ann then hit the tab key to complete the name.  Using the tab key helps avoid spelling mistakes and ensures that the dataframe is available in the place we are looking for it.

str(annotatedDEgenes)

#It may help to widen this window so the info for each column is displayed on one line.
```
Ok, thats a lot to unpack! Some things to notice:

The object type data.frame is displayed in the first row along with its dimensions, in this case 130 observations (rows) and 13 variables (columns)

Each variable (column) has a name (e.g. GeneID). This is followed by the object mode (e.g. factor, int, num, etc.). Notice that before each variable name there is a $ - this will be important later.
So from both summary and str, we know that our data frame had 13 variables that summarize the data.

Base.mean, log2.FC. and P.value variables (and several others) are numerical data

From the summary function, we get summary statistics on the min and max values for these columns, as well as mean, median, and interquartile ranges

Many of the other variables (e.g. Strand) are treated as categorical data

This type has special treatment in R - more on this in a bit. The most frequent 6 different categories and the number of times they appear (e.g. the Strand called - appeared 58 times) are displayed. Another example is the protein_coding value for Feature which appeared in 126 observations.

## Factors

Factors, the final major data structure we will introduce, can be thought of as vectors which are specialized for categorical data. Given Râ€™s specialization for statistics, this make sense since categorial and continuous variables usually have different treatments. Sometimes you may want to have data treated as a factor, but in other cases, this may be undesirable.

A factor let's you organize data by categories.  For example, if you had data on organisms based on the old kingdom rules you might have plant, animal, fungi ... as factors.  Then you could act perform a function only on animals for example.

Since some of the data in our data frame are factors, lets see how factors work.

When we import the data using the command above, the character data did not come in as factor data as it is supposed to according to the galaxy walkthrough.

Here, we can convert the chr data to factor data, so that our data frame is consistent with the tutorial.  There are various ways to do this.  Here we will try a function from the dplyr package called mutateif.  This will change (mutate) data in a dataframe based on some condition.  We will cover some other basic functions of dplyr a bit later.

first we need to install and load the dplyr pakcge.  dplyr is part of what is called the tidyverse, so we'll install the tiduverse which has lots of other useful packages.

```{r}
install.packages("tidyverse")
library(tidyverse)

```
now wecan run mutate_if, because it is part of the now loaded dplyr package

```{r}
#we will store the modified data frame with the same name 

annotatedDEgenes <- annotatedDEgenes %>% mutate_if(is.character, as.factor)

#the above code can be read as follows:  
#The expression on the right says: input the annotatedDEgenes datframe into the mutateif function.  Within this functio look for everything that is a character (is.character) and change it to factor (as.factor).  the annotatedDEgenes on the left is saying to take the results of the function on the right and store it back in the annotatedDEgenes variable.  Let's see if it works.  Run this code block.
```

Now let's look at the data frame and see if we have factor data

```{r}
#check structure of modified dataframe.
str(annotatedDEgenes)
```


```{r}
## extract the "feature" column to a new object
feature <- annotatedDEgenes$Feature

# here's where that dollar sign symbol comes in.  Using the $ symbol we can designate specific columns.  annotatedDEgene$Feature refers to the Feature column of the annotatedDEgenes dataframe.


```

Let's look at the first few entries n the Feature column using the head() function.

```{r}
#we could use the head function directly on the features column within the dta frame like this:

head(annotatedDEgenes$Feature)

#But because we already extracted that column into a new object called feature, we can do this

head(feature)

# both give the same thing.  The fact that it list levels tells us that the data is being treated as a factor.

```
We can also check how many levels there are by using the levels function.  This function works on 

```{r}
#check how many levels in the feature column that we just extracted.
levels(feature)
```

And let's check the stucture of feature

```{r}
str(feature)

```
To get an idea of how factor data can be useful, let's make a basic plot of the feature data.  In base R there is a function called plot().  It is a quick way to generate a plot (or graph) of some data.  The function generally figures out the best type of plot based on the data.  While this is helpful for quick looks at the data, more advanced plotting techniques are available.  We'll cover those later.

Here let's just plot the feature data

```{r}
#generate a simple plot of feature data

plot(feature)

```

Simple enough.  The plot function counted up the number of genes in each of of the factor "levels" and made a bar graph.  If the data wasn't in factor form, plot would not generate this plot.  Let's demonstrate

```{r}
#convert feature data back to character.  Save it as feature_chr

feature_chr <- as.character(feature)

```

Let' see if that worked

```{r}
#check structure of feature chr vector
str(feature_chr)

#now try to plot it
plot(feature_chr)

```

Note that the plot didn't know what to do with this data.  We could certainly write some ode to count up the number of each type of gene, but the factor aspect of the data makes it much easier.

Now let's remove the factor_chr data to avoid confusion

```{r}
rm(feature_chr)
```

###Subset a data frame

Now we would like to know how to get specific values from data frames, and where necessary, change the mode of a column of values.

A data frame is two-dimensional (rows and columns). Therefore, to select a specific value we will use [] (bracket) notation.  The basic way to subset the data frame is to indicate the row as the first number and the column as the second number.  It looks like this, where df stands for the name of the data frame.

Here are some ways to write the subsetting notation.  In general,

Use of 2 values, separated by commas: data.frame[row, column]
Use of a colon between the numbers (start:stop, inclusive) for a continuous range of numbers (e.g. dataframe[1:4, 2])
Passing a vector using c() for a non continuous set of numbers
Index using the name of a column(s) by passing them as vectors using c()

SOme more general examples:

df[1,1]  selects the value in the first row, first column.

df [2, 4] selects the value in the second row, fourth column.

df[2, ] selects the second row, all columns (the commas is necessary.  df[2] would give an error)
df[-1, ] all rows except the last.  all columns
df[1:4, 1] rows 1 through 4, all columns

** you can also select columns by name.  the c() notation allows you to combine more than one column name.  Also - quotes are necessary for column names. **

df[1:10, c("Name of column 3", "Name of column 6")] rows 1 through 10, columns 3 and 6.

df[, c("column")] all rows 
head(df) the first 6 rows (6 is the default number of rows for the head function
head(df, 10).  The first 10 rows
tail(df) the last 6 rows (6 is the default number of rows for the tail function
tail(df, 10).  The last 10 rows

you can specify specific columns using dollar sign notation.  Generally this looks like 

df$columnName

A very useful feature is being to be able to select rows based on the value in that row for a specific column.

A general example would look like this,

```{r}
#df[df$ColumnName == "someSpecificTerm"].  The first df indicates the data frame name, the df$ColumnName part says "look in this column".  the == means "if it matches" "someSPecificTerm" is the thing to be matched.  This notation takes some getting used to and will be clearer wth real examples.

#I had to put this part in a code block because the $ symbol has a special interpretation in the R markdown part of the document.
```

Here are some examples uisng the annotatedDEgenes dataframe.  Run each line separately by placing your cursor at the end of the line and typing the ctrl-enter key combination

First I'll recall the column names so we know what to expect.  Also the rows are just specific geneIDs

```{r}
colnames(annotatedDEgenes)
```


```{r}
annotatedDEgenes[1, 1] #first row first column (the 1st geneID)
annotatedDEgenes[2, 4] #second row fourth column (a StdErr value for gene 2)
annotatedDEgenes[130, 13] #The last gene name
annotatedDEgenes[2, ] #all columns for row 2
annotatedDEgenes[-1, ] #All rows except the last all columns
annotatedDEgenes[1:4, 1] #genes 1-4, geneID
annotatedDEgenes[1:10, c("Feature", "Gene.name")] # rows 1-10, the Feature and Gene.name column*
annotatedDEgenes[, "Gene.name"] #the Gene name for all rows.
head(annotatedDEgenes)# first 6 rows
head(annotatedDEgenes, 10)# first 10 rows
tail(annotatedDEgenes) #last 6
tail(annotatedDEgenes, 10) #last 10
annotatedDEgenes$GeneID #the gene ID colun
annotatedDEgenes[annotatedDEgenes$Feature == "pseudogene", ] #all rows (genes) in the Feature column that match the term "pseudogene" (apparently there is only one)

#note"  the following doesn't work.  You need to designate the column as annotatedDEgenes$Feature

annotatedDEgenes["Feature" == "pseudogene", ]

#This does work
annotatedDEgenes[annotatedDEgenes[12] == "pseudogene", ]


annotatedDEgenes[annotatedDEgenes$Feature != "protein_coding", ] #all rows where the feature does not equal (!= means not equal or doesn't match) protein_coding.
```


### Creating a new data frame containing a subset of the data from the original.

Let's say we want all of the genes that are transcribed from the positive strand of the genome.  This information is contained in the "Strand" column, which is column 11. This column is a factor, with 2 levels.  The levels are + and -.

Recall that factors allow us to do a simple plot of the count of each type of factor.  try that now for the strands column.  Use the dollar sign notation to designate the strand column.

```{r}
#your code here

plot(annotatedDEgenes$Strand)
```

Now let's selct all of the genes on the positive strand and add them to as a new data frame in a new variable called annotatedDEgenes_plusStrand

```{r}
# create a new data frame containing only observations from the "+" strand
annotatedDEgenes_plusStrand <- annotatedDEgenes[annotatedDEgenes$Strand == "+",]
```

How many did you get?  Is this number consistent with your plot above?

Check the dimensions and structure of your new data frame and generate an overall summary

```{r}
#dimensions (number of rows and columns)
dim(annotatedDEgenes_plusStrand)

#structure
str(annotatedDEgenes_plusStrand)

#summary
summary(annotatedDEgenes_plusStrand)

```

### Change type of columns

Above we changed character colimns to factor.  This section goes over how to do this.

Sometimes, it is possible that R will misinterpret the type of data represented in a data frame, or store that data in a mode which prevents you from operating on the data the way you wish. For example, a long list of gene names isnâ€™t usually thought of as a categorical variable, the way that your experimental condition (e.g. control, treatment) might be. More importantly, some R packages you use to analyze your data may expect characters as input, not factors. At other times (such as plotting or some statistical analyses) a factor may be more appropriate. Ultimately, you should know how to change the mode of an object.

First, its very important to recognize that coercion happens in R all the time. This can be a good thing when R gets it right, or a bad thing when the result is not what you expect.  Coercion means that R "decide" what type the data should be and coerces it to be that type.  Sometimes we need to change this.

To demonstrate we will work tith the Gene.name column of the annotatedDEgenes dataframe.

```{r}
#look at the structure of the gene.name column.  NOtice that the data is a factor.

str(annotatedDEgenes$Gene.name)

```
The result shows that this column is a factor with 130 levels.  The numbers following refer to each level.  That is, each level is assigned a particular number, levl 1, 2, 3 etc.

This column contains the name of each gene.  It doesn't make sense to treat these as a factor.  Each factor, or category would just contain one gene name.  Let's convert this coulmn to chaarcter.  it's pretty simple

```{r}
#convert annotaedDEgenes$Gene.name to character

annotatedDEgenes$Gene.name <- as.character(annotatedDEgenes$Gene.name)

# Now let's look at the structure again

str(annotatedDEgenes$Gene.name)
```
One way to avoid needless coercion when importing a data frame using functions such as read.csv() is to set the argument StringsAsFactors to FALSE. By default, this argument is TRUE. Setting it to FALSE will treat any non-numeric column to a character type. Going through the read.csv() documentation, you will also see you can explicitly type your columns using the colClasses argument. Other R packages (such as the Tidyverse readr) donâ€™t have this particular conversion issue, but many packages will still try to guess a data type.

### Inspect a numerical column using math, sorting, renaming ...

Here are a few operations that donâ€™t need much explanation, but which are good to know. There are lots of arithmetic functions you may want to apply to your data frame. For example, you can use functions like mean(), min(), max() on an individual column.

Letâ€™s look at the Base.mean column, i.e. the mean of normalized counts of all samples, normalizing for sequencing depth and library composition.

```{r}
# Get the maximum value
max(annotatedDEgenes$Base.mean)
```
Sort the data (highest to lowest).  Instead of a function called sort, R uses a function called order.  

```{r}
#sort the Basemean column
order(annotatedDEgenes$Base.mean)

```

Ote that this gives a bunch of numbers that don't appear to be in order.  These numbers are the indices of each row.  So row # 117 has the highes Base.mean.  This function doesn't return the actual values in the column, it just returns the new order.

Also, The above command doesn't change the dataframe, it just sorts the column and returns the result.  We can do this to create a new dataframe with all of the values soreted by Basemean.  We will save this in a new variable called sorted_byBaseMean

```{r}
sorted_BaseMean <- annotatedDEgenes[order(annotatedDEgenes$Base.mean),]
```

So, in the above command we sort the annotated genes dataframe, then store it in the new variable.  A way to read the sorting part (the right side of the above expression) in english is:

"acting on the annotatedDEgene dataframe, reorder the rows according to the Base.mean column.  and return all of the columns".  The "return all of the columns" part is accomplished by using the comma after annotatedDEgenes$Base.mean)

Let's have a look and see if the above command worked.  We should have a new dataframe called sorted_BaseMean.  And it should be sorted by Base.mean.  We can use the head command to see the first 6 rows.

```{r}
head(sorted_BaseMean)
```
notice that this automatically sorts from lowest to highest value.  If we wanted to repeat the above from highest to lowest we could do include the decreasing = TRUE argument: 

annotatedDEgenes[order(annotatedDEgenes$Base.mean, decreasing = TRUE)

Let's do that, but rather than saving it as a new data frame, let's just look at the first six lines using the head function again.  That is we "feed" the annotatedDEgenes[order(annotatedDEgenes$Base.mean, decreasing = TRUE) statement directly to the head function, without first storing it in a variable.

```{r}
#sort by Base.mean in decreasing order.

head(annotatedDEgenes[order(annotatedDEgenes$Base.mean, decreasing = TRUE),])
```

